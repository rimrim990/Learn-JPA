## 엔티티 설계시 주의점

### 엔티티에는 가급적 Setter 를 사용하지 말자
- Setter 가 모두 열려있으면 변경 포인트가 너무 많아 유지보수가 어렵다

### 모든 연관관계는 지연로딩으로 설정 !
- 즉시로딩 (`EAGER`) 은 예측이 어렵고, 어떤 SQL 이 실행될지 예측하기 어렵다. 특히 JPQL 을 실행할 때 N+1 문제가 자주 발생한다
  - 즉시로딩은 연관된 데이터를 모두 가져온다
- 실무에서 모든 연관관계는 지연로딩 (`LAZY`) 로 설정해야 한다
- 연관된 엔티티를 함께 DB 에서 조회해야 하면, **fetch join** 또는 **엔티티 그래프 기능**을 사용한다
- @XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로, 직접 지연로딩으로 설정해야 한

## 변경 감지와 병합 (merge)

### 영속 엔티티
- 영속 상태의 엔티티는 JPA 에 의해 관리되며, 트랜잭션 커밋 시점에 변경 내용을 감지하여 DB 에 반영해준다

### 준영속 엔티티
- 영속성 컨텍스트에서 더는 관리하지 않는 엔티티를 말한다
- ex. 식별자를 가지고 있는 새로 생성된 객체 

**준영속 엔티티를 수정하는 2가지 방법**
- 변경 감지 기능 사용 (더치 체킹)
- 병합

### 병합 동작 방식
- 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티 조회
- 1차 캐시에 없으면 데이터베이스에서 엔티티 조회하고 1차 캐시에 저장
- 조회된 영속 엔티티에 파라미터로 넘어온 값을 채워 넣어 반환

**주의**
- 변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있다
- 병합은 모든 속성이 변경된다 
- 값이 없으면 `null` 로 설정된다
- 엔티티를 변경할 때는 항상 변경 감지 사용 !

## API 개발 고급

### 페이징과 한계 돌파
- 컬렉션을 페치 조인하면 페이징이 불가능하다
  - 컬렉션을 패치 조인하면 데이터가 예측할 수 없이 증가한다
  - 일대다에서는 일을 기준으로 페이징하는 것이 목적이지만, 데이터는 다를 기준으로 row 가 생성된다
- 이 경우 하이버네이트는 경고 로그를 남기고 모든 DB 데이터를 읽어서 **메모리에서 페이징을 시도**한다. 최악의 경우 장애로 이어질 수 있다

**한계 돌파**
- ToOne 관계는 모두 페치조인 한다. row 수가 증가하지 않으므로 페이징 쿼리에 영향을 주지 않는다
- 컬렉션은 지연 로딩으로 조회한다
  - 지연 로딩 성능 최적화를 위해 `@BatchSize` 를 적용한다
  - 컬렉션이나, 프록시 객체를 한꺼번에 설정한 size 만큼 IN 쿼리로 조회한다
  