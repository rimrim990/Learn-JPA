## 영속성 컨텍스트

### 엔티티 조회, 1차 캐시
- 영속성 컨텍스트 내부에 **1차 캐시**가 존재하며, primary key 와 엔티티 객체 매핑을 갖고 있음
- 조회 요청이 들어오면 1차 캐시에서 먼저 조회
- 1차 캐시에 존재하지 않으면 데이터베이스에서 조회한 후, **1차 캐시에 저장**
- 엔티티 매니저는 사용자 트랜잭션 단위로 생성, 삭제되기 때문에 애플리케이션 전체에서 공유되는 캐시가 아님
- 동일성 보장 (1차 캐시에서 관리되는 동일한 객체)

### 쓰기 지연
- 쓰기 지연 SQL 저장소에 INSERT SQL **쿼리 생성하여 보관**
- 트랜잭션이 **커밋되는 시점**에 SQL 실행 (flush) - **버퍼링**

### 변경 감지 (더티 체킹)
- 영속 상태의 엔티티일 경우, 값을 수정하면 UPDATE 쿼리 생성
- 커밋 시점에 **1차 캐시에서 엔티티와 스냅샷을 비교** 후, 업데이트 쿼리를 쓰기 지연 SQL 저장소에 생성

### 플러시
- 영속성 컨텍스트의 변경내용을 데이터베이스에 반영

**플러시 발생**
- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송 (등록, 수정, 삭제)

**플러시 방법**
- 영속 컨텍스트의 변경내용을 데이터베이스에 **동기화** - 커밋 직전에만 동기화하면 됨
- em.flush() - 직접 호출
- 트랜잭션 커밋 - 자동 호출
- JPQL 쿼리 실행 - 자동 호출
  - JPQL 은 1차 캐시를 거치지 않고 SQL 을 실행하기 때문에 flush 가 호출된 상태여야 한다

### 데이터베이스 스키마 자동 생성
- 운영 장비에는 절대 create, create-drop, update 사용하면 안된다
- 스테이징과 운영 서버는 validate 또는 none

### 연관관계의 주인과 mappedBy
**객체와 테이블 관계의 차이**
- 객체 연관관계 = 2개
  - 멤버 -> 팀 (단방향)
  - 팀 -> 멤버 (단방향)
- 테이블 연관관계 = 1개
  - 멤버 <-> 팀 (외래키)
- 객체를 양방향으로 참조하려면 단방향 연관관계 2개를 만들어야 한다

**연관관계의 주인**
- 외래 키가 있는 곳을 주인으로 지정해라 !
- 연관관계의 주인만이 **외래 키를 관리 (등록, 수정)**
- 주인이 아닌쪽은 읽기만 가능
- 주인이 아니면 mappedBy 속성으로 주인 지정

**다대다 연관관계**
- 관계형 데이터베이스는 테이블 2개로 다대다 관계를 표현할 수 없음
- 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야 한다
- 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능
- 편리해 보이지만 실무에서 사용 X
  - 실무에서 연결 테이블이 단순히 연결만 하고 끝나지 않음 - 다대다는 컬럼을 추가할 수 없음
  - `@OneToMany`, `@ManyToOne` 로 풀어서 사용하자 ! (연결 테이블을 엔티티로 승격)